# ğŸ† Verifiable AI Trading Arena - MVP è§„åˆ’æ–¹æ¡ˆ

## ğŸ“‹ é¡¹ç›®æ¦‚è¿°

**é¡¹ç›®åç§°**: Verifiable AI Trading Arena (å¯éªŒè¯AIäº¤æ˜“ç«æŠ€åœº)

**æ ¸å¿ƒç†å¿µ**: è®© AI äº¤æ˜“ä»"æ¦‚ç‡"å˜æˆ"ç§‘å­¦" â€” å®ç°ç­–ç•¥ã€æ‰§è¡Œã€ç»“æœçš„å…¨æµç¨‹é€æ˜ä¸å¯éªŒè¯

**æ¯”èµ›è¦æ±‚**: 5å°æ—¶å†…å®ŒæˆMVPï¼ŒæˆåŠŸéƒ¨ç½²è‡³0G Galileoæµ‹è¯•ç½‘

---

## ğŸ¯ äº§å“ç»ˆæ€è®¾è®¡

### å®Œæ•´äº§å“æ„¿æ™¯

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    AI Trading Arena æ¶æ„                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Layer 1: å‰ç«¯ç•Œé¢                                               â”‚
â”‚  â”œâ”€â”€ ç­–ç•¥æ³¨å†Œ/æäº¤é¡µé¢                                            â”‚
â”‚  â”œâ”€â”€ å®æ—¶æ’è¡Œæ¦œ Dashboard                                        â”‚
â”‚  â”œâ”€â”€ ç­–ç•¥è¯¦æƒ…/å¯éªŒè¯è®°å½•æŸ¥çœ‹                                       â”‚
â”‚  â””â”€â”€ é’±åŒ…è¿æ¥ & ç”¨æˆ·ä¸­å¿ƒ                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Layer 2: æ ¸å¿ƒæ™ºèƒ½åˆçº¦ (0G Chain)                                 â”‚
â”‚  â”œâ”€â”€ StrategyRegistry.sol (ç­–ç•¥æ³¨å†Œï¼ŒåŸºäºERC-7857 INFT)            â”‚
â”‚  â”œâ”€â”€ TradingArena.sol (ç«æŠ€åœºæ ¸å¿ƒé€»è¾‘)                            â”‚
â”‚  â”œâ”€â”€ ResultVerifier.sol (ç»“æœéªŒè¯)                               â”‚
â”‚  â””â”€â”€ Leaderboard.sol (æ’åä¸å¥–åŠ±åˆ†é…)                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Layer 3: æ•°æ®å±‚ (0G DA + Storage)                               â”‚
â”‚  â”œâ”€â”€ ç»Ÿä¸€å¸‚åœºæ•°æ®è¾“å…¥ (DAå±‚)                                       â”‚
â”‚  â”œâ”€â”€ ç­–ç•¥å…ƒæ•°æ®å­˜å‚¨ (0G Storage)                                  â”‚
â”‚  â”œâ”€â”€ æ‰§è¡Œæ—¥å¿—å­˜å‚¨ (0G Storage)                                    â”‚
â”‚  â””â”€â”€ å†å²è®°å½• & å¯éªŒè¯è¯æ˜                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Layer 4: æ‰§è¡Œå±‚ (0G Compute)                                    â”‚
â”‚  â”œâ”€â”€ å¯ä¿¡æ‰§è¡Œç¯å¢ƒ (TEE)                                           â”‚
â”‚  â”œâ”€â”€ å›æµ‹å¼•æ“                                                    â”‚
â”‚  â””â”€â”€ å®æ—¶æ¨¡æ‹Ÿäº¤æ˜“æ‰§è¡Œ                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒåŠŸèƒ½æ¨¡å—

| æ¨¡å— | åŠŸèƒ½æè¿° | 0GæŠ€æœ¯ |
|------|----------|--------|
| ç­–ç•¥æ³¨å†Œ | ç”¨æˆ·æäº¤AIäº¤æ˜“ç­–ç•¥ï¼Œé“¸é€ ä¸ºINFT | ERC-7857 + 0G Storage |
| æ•°æ®è¾“å…¥ | ç»Ÿä¸€çš„å¸‚åœºæ•°æ®æºï¼Œç¡®ä¿å…¬å¹³ç«äº‰ | 0G DA |
| å¯ä¿¡æ‰§è¡Œ | ç­–ç•¥åœ¨å¯ä¿¡ç¯å¢ƒä¸­æ‰§è¡Œ/å›æµ‹ | 0G Compute |
| ç»“æœè®°å½• | æ‰€æœ‰äº¤æ˜“ç»“æœä¸Šé“¾ï¼Œä¸å¯ç¯¡æ”¹ | 0G DA + Log |
| æ’åç³»ç»Ÿ | è‡ªåŠ¨è®¡ç®—æ’åï¼Œæ™ºèƒ½åˆçº¦ç»“ç®— | 0G Chain |
| å¯éªŒè¯æ€§ | ä»»ä½•äººå¯å¤ç°å’ŒéªŒè¯ç­–ç•¥è¡¨ç° | å…¨æ ˆ0G |

---

## ğŸš€ MVP åŠŸèƒ½èŒƒå›´ (5å°æ—¶å¯å®Œæˆ)

### MVP æ ¸å¿ƒåŠŸèƒ½ âœ…

1. **ç­–ç•¥æ³¨å†Œç³»ç»Ÿ**
   - ç®€åŒ–ç‰ˆERC-721åˆçº¦ï¼ˆä¸ç”¨å®Œæ•´ERC-7857ï¼‰
   - ç­–ç•¥å…ƒæ•°æ®Hashä¸Šé“¾
   - ç­–ç•¥æ–‡ä»¶ä¸Šä¼ åˆ°0G Storage

2. **æ¨¡æ‹Ÿäº¤æ˜“ç«æŠ€åœº**
   - ç®€åŒ–çš„ä»·æ ¼æ¨¡æ‹Ÿå™¨
   - åŸºç¡€äº¤æ˜“è®°å½•
   - ç»“æœHashä¸Šé“¾

3. **æ’è¡Œæ¦œå±•ç¤º**
   - å®æ—¶æ’åè®¡ç®—
   - æ”¶ç›Šç‡å±•ç¤º
   - ç­–ç•¥è¯¦æƒ…æŸ¥çœ‹

4. **å‰ç«¯ç•Œé¢**
   - é’±åŒ…è¿æ¥
   - ç­–ç•¥æäº¤è¡¨å•
   - æ’è¡Œæ¦œé¡µé¢

### MVP ç®€åŒ–å†³ç­–

| å®Œæ•´ç‰ˆåŠŸèƒ½ | MVPç®€åŒ–ç‰ˆ |
|-----------|----------|
| ERC-7857 å®Œæ•´å®ç° | ç®€åŒ–ç‰ˆERC-721 + metadata hash |
| 0G Computeå¯ä¿¡æ‰§è¡Œ | é“¾ä¸‹æ¨¡æ‹Ÿ + ç»“æœhashä¸Šé“¾ |
| å®æ—¶å¸‚åœºæ•°æ® | æ¨¡æ‹Ÿä»·æ ¼æ•°æ® |
| å¤æ‚ç­–ç•¥æ‰§è¡Œ | ç®€å•ä¹°å–ä¿¡å· |

---

## ğŸ§© ç­–ç•¥ INFT è®¾è®¡ï¼ˆMVP è§„åˆ™é©±åŠ¨ï¼‰

### ç›®æ ‡ä¸è¾¹ç•Œ
- è§„åˆ™é©±åŠ¨ç­–ç•¥ï¼Œå‚è€ƒ freqtrade çš„â€œä¿¡å·-æ‰§è¡Œâ€åˆ†å±‚
- å•ä¸€å›ºå®šæ ‡çš„ã€åˆ†é’Ÿçº§ K çº¿ã€åˆçº¦åŒå‘
- å…¨ä»“è¿›å‡º + å›ºå®šæ­¢æŸ/æ­¢ç›ˆç™¾åˆ†æ¯”
- å¯å¤ç®—ä¸ºç¬¬ä¸€åŸåˆ™ï¼ˆæ— æœªæ¥å‡½æ•°ã€seed â‰¡ incrementalï¼‰

### é“¾ä¸Šæœ€å°å¯éªŒè¯å­—æ®µ
- `codeHash`ï¼šç­–ç•¥ä»£ç å“ˆå¸Œ
- `paramsHash`ï¼šå‚æ•°å“ˆå¸Œ
- `datasetVersion`ï¼šåˆ†é’Ÿçº§æ•°æ®ç‰ˆæœ¬
- `evalWindow`ï¼šè¯„æµ‹çª—å£ï¼ˆèµ·æ­¢æ—¶é—´ï¼‰
- `backtestLogHash`ï¼šå›æµ‹æ—¥å¿—å“ˆå¸Œ
- `strategyId`ã€`creator`ã€`createdAt`

### é“¾ä¸‹å­˜è¯ææ–™
- ç­–ç•¥æ–‡ä»¶ä¸å‚æ•° JSON
- æ•°æ®åˆ‡ç‰‡ç´¢å¼•ä¸å›æµ‹æ—¥å¿—åŸæ–‡

### éªŒè¯ä¸æ’åå£å¾„
- éªŒè¯æµç¨‹: å¤ç®—å›æµ‹æ—¥å¿— â†’ å¯¹æ¯” `backtestLogHash`
- æ’åå£å¾„: MVP ä»…ä½¿ç”¨å•ä¸€æŒ‡æ ‡ï¼ˆå¦‚ç´¯è®¡æ”¶ç›Šæˆ–å‡€å€¼æ”¶ç›Šç‡ï¼‰
- å›ºå®šå‡è®¾: æ‰‹ç»­è´¹ã€æ»‘ç‚¹ã€æ æ†ä¸Šé™å›ºå®š
- ç»“æœæ— æ•ˆæ¡ä»¶: æ—¥å¿—ä¸­æ–­ã€æ•°æ®ç¼ºå¤±ã€å“ˆå¸Œä¸ä¸€è‡´

---

## ğŸ§ª æœ€å°ç­–ç•¥æ ·ä¾‹ JSON + å“ˆå¸Œæµç¨‹

### æ ·ä¾‹ï¼ˆé“¾ä¸‹å…ƒæ•°æ® JSONï¼‰
```json
{
  "strategy": { "name": "rsi-threshold-v1", "version": "1.0.0", "author": "anon", "description": "RSI é˜ˆå€¼å¤šç©º" },
  "instrument": { "symbol": "BTC/USDT", "timeframe": "1m", "market": "perp" },
  "logic": {
    "type": "indicator-threshold",
    "indicators": ["rsi(14)"],
    "rules": [
      { "if": "rsi < 30", "then": "entry_long" },
      { "if": "rsi > 70", "then": "entry_short" },
      { "if": "rsi > 50", "then": "exit_long" },
      { "if": "rsi < 50", "then": "exit_short" }
    ],
    "slPct": 0.02,
    "tpPct": 0.04
  },
  "execution": { "position": "all-in", "direction": "long+short", "feeBps": 4, "slippageBps": 6, "leverage": 2 },
  "verification": { "datasetVersion": "v1", "evalWindow": "2025-01-01~2025-02-01", "backtestLogHash": "0x..." }
}
```

### å“ˆå¸Œè®¡ç®—æµç¨‹ï¼ˆå»ºè®®ï¼‰
1) è§„èŒƒåŒ– JSONï¼ˆå­—æ®µæ’åºã€å»ç©ºç™½ï¼‰  
2) `codeHash = keccak256(strategy_code_bytes)`  
3) `paramsHash = keccak256(canonical_json_bytes)`  
4) æ‰§è¡Œå›æµ‹ç”Ÿæˆ `backtestLog`ï¼Œè®¡ç®— `backtestLogHash`  
5) å°† `codeHash/paramsHash/datasetVersion/evalWindow/backtestLogHash` ä¸Šé“¾

---

## ğŸ“ é¡¹ç›®ç»“æ„

```
ai-trading-arena/
â”œâ”€â”€ contracts/                    # æ™ºèƒ½åˆçº¦
â”‚   â”œâ”€â”€ StrategyNFT.sol          # ç­–ç•¥NFTåˆçº¦
â”‚   â”œâ”€â”€ TradingArena.sol         # ç«æŠ€åœºæ ¸å¿ƒåˆçº¦
â”‚   â””â”€â”€ interfaces/
â”‚       â””â”€â”€ IStrategyNFT.sol
â”œâ”€â”€ frontend/                     # å‰ç«¯åº”ç”¨
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”œâ”€â”€ WalletConnect.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ StrategySubmit.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Leaderboard.tsx
â”‚   â”‚   â”‚   â””â”€â”€ StrategyDetail.tsx
â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”‚   â”œâ”€â”€ useContract.ts
â”‚   â”‚   â”‚   â””â”€â”€ useStorage.ts
â”‚   â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”‚   â”œâ”€â”€ 0g-storage.ts
â”‚   â”‚   â”‚   â””â”€â”€ contracts.ts
â”‚   â”‚   â””â”€â”€ App.tsx
â”‚   â””â”€â”€ package.json
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ deploy.ts                # éƒ¨ç½²è„šæœ¬
â”‚   â””â”€â”€ simulate.ts              # æ¨¡æ‹Ÿäº¤æ˜“è„šæœ¬
â”œâ”€â”€ test/
â”‚   â””â”€â”€ TradingArena.test.ts
â”œâ”€â”€ hardhat.config.ts
â””â”€â”€ README.md
```

---

## â° 5å°æ—¶å¼€å‘æ—¶é—´è¡¨

### Phase 1: ç¯å¢ƒæ­å»º (30åˆ†é’Ÿ)

```bash
# 1. åˆå§‹åŒ–é¡¹ç›®
mkdir ai-trading-arena && cd ai-trading-arena
npm init -y

# 2. å®‰è£…ä¾èµ–
npm install --save-dev hardhat @nomicfoundation/hardhat-toolbox typescript
npm install ethers @0glabs/0g-ts-sdk dotenv
npm install @openzeppelin/contracts

# 3. åˆå§‹åŒ–Hardhat
npx hardhat init

# 4. é…ç½®ç¯å¢ƒå˜é‡
# .env æ–‡ä»¶
PRIVATE_KEY=your_private_key
RPC_URL=https://evmrpc-testnet.0g.ai
STORAGE_INDEXER=https://indexer-storage-testnet-turbo.0g.ai
```

**hardhat.config.ts é…ç½®:**
```typescript
import { HardhatUserConfig } from "hardhat/config";
import "@nomicfoundation/hardhat-toolbox";
import * as dotenv from "dotenv";
dotenv.config();

const config: HardhatUserConfig = {
  solidity: {
    version: "0.8.19",
    settings: {
      evmVersion: "cancun",
      optimizer: { enabled: true, runs: 200 }
    }
  },
  networks: {
    "0g-testnet": {
      url: "https://evmrpc-testnet.0g.ai",
      chainId: 16602,
      accounts: [process.env.PRIVATE_KEY || ""]
    }
  }
};
export default config;
```

### Phase 2: æ™ºèƒ½åˆçº¦å¼€å‘ (1.5å°æ—¶)

**contracts/StrategyNFT.sol:**
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract StrategyNFT is ERC721, ERC721URIStorage, Ownable {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;
    
    // ç­–ç•¥å…ƒæ•°æ®
    struct Strategy {
        bytes32 codeHash;        // ç­–ç•¥ä»£ç çš„hash
        bytes32 paramsHash;      // å‚æ•°hash
        string datasetVersion;   // æ•°æ®é›†ç‰ˆæœ¬
        string evalWindow;       // è¯„æµ‹çª—å£
        string storageRoot;      // 0G Storage root hash
        uint256 createdAt;
        address creator;
        bool isActive;
    }
    
    mapping(uint256 => Strategy) public strategies;
    
    event StrategyRegistered(
        uint256 indexed tokenId, 
        address indexed creator, 
        bytes32 codeHash,
        bytes32 paramsHash,
        string datasetVersion,
        string evalWindow,
        string storageRoot
    );
    
    constructor() ERC721("AI Trading Strategy", "AITS") {}
    
    function registerStrategy(
        bytes32 _codeHash,
        bytes32 _paramsHash,
        string memory _datasetVersion,
        string memory _evalWindow,
        string memory _storageRoot,
        string memory _tokenURI
    ) external returns (uint256) {
        _tokenIds.increment();
        uint256 newTokenId = _tokenIds.current();
        
        _safeMint(msg.sender, newTokenId);
        _setTokenURI(newTokenId, _tokenURI);
        
        strategies[newTokenId] = Strategy({
            codeHash: _codeHash,
            paramsHash: _paramsHash,
            datasetVersion: _datasetVersion,
            evalWindow: _evalWindow,
            storageRoot: _storageRoot,
            createdAt: block.timestamp,
            creator: msg.sender,
            isActive: true
        });
        
        emit StrategyRegistered(
            newTokenId,
            msg.sender,
            _codeHash,
            _paramsHash,
            _datasetVersion,
            _evalWindow,
            _storageRoot
        );
        return newTokenId;
    }
    
    function getStrategy(uint256 tokenId) external view returns (Strategy memory) {
        require(_exists(tokenId), "Strategy does not exist");
        return strategies[tokenId];
    }
    
    function totalStrategies() external view returns (uint256) {
        return _tokenIds.current();
    }
    
    // Override required functions
    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {
        super._burn(tokenId);
    }
    
    function tokenURI(uint256 tokenId) public view override(ERC721, ERC721URIStorage) returns (string memory) {
        return super.tokenURI(tokenId);
    }
    
    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721URIStorage) returns (bool) {
        return super.supportsInterface(interfaceId);
    }
}
```

**contracts/TradingArena.sol:**
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./StrategyNFT.sol";

contract TradingArena {
    StrategyNFT public strategyNFT;
    
    struct TradingResult {
        uint256 strategyId;
        int256 pnl;              // ç›ˆäº (basis points, 10000 = 100%)
        uint256 totalTrades;
        uint256 winningTrades;
        bytes32 executionLogHash; // æ‰§è¡Œæ—¥å¿—çš„hash (å­˜å‚¨åœ¨0G Storage)
        uint256 timestamp;
        uint256 roundId;
    }
    
    struct Round {
        uint256 startTime;
        uint256 endTime;
        bytes32 marketDataHash;  // è¯¥è½®æ¬¡ä½¿ç”¨çš„å¸‚åœºæ•°æ®hash
        bool finalized;
    }
    
    uint256 public currentRound;
    mapping(uint256 => Round) public rounds;
    mapping(uint256 => mapping(uint256 => TradingResult)) public results; // roundId => strategyId => result
    mapping(uint256 => uint256[]) public roundParticipants; // roundId => strategyIds
    
    // æ’è¡Œæ¦œ
    mapping(uint256 => int256) public totalPnL; // strategyId => cumulative PnL
    
    event RoundStarted(uint256 indexed roundId, bytes32 marketDataHash);
    event ResultSubmitted(uint256 indexed roundId, uint256 indexed strategyId, int256 pnl);
    event RoundFinalized(uint256 indexed roundId);
    
    constructor(address _strategyNFT) {
        strategyNFT = StrategyNFT(_strategyNFT);
    }
    
    // å¼€å§‹æ–°ä¸€è½®ç«èµ›
    function startNewRound(bytes32 _marketDataHash) external {
        currentRound++;
        rounds[currentRound] = Round({
            startTime: block.timestamp,
            endTime: 0,
            marketDataHash: _marketDataHash,
            finalized: false
        });
        
        emit RoundStarted(currentRound, _marketDataHash);
    }
    
    // æäº¤äº¤æ˜“ç»“æœ (ç”±å¯ä¿¡æ‰§è¡Œè€…è°ƒç”¨ï¼ŒMVPé˜¶æ®µç®€åŒ–ä¸ºä»»ä½•äººå¯æäº¤)
    function submitResult(
        uint256 _strategyId,
        int256 _pnl,
        uint256 _totalTrades,
        uint256 _winningTrades,
        bytes32 _executionLogHash
    ) external {
        require(rounds[currentRound].startTime > 0, "No active round");
        require(!rounds[currentRound].finalized, "Round finalized");
        require(strategyNFT.ownerOf(_strategyId) != address(0), "Invalid strategy");
        
        results[currentRound][_strategyId] = TradingResult({
            strategyId: _strategyId,
            pnl: _pnl,
            totalTrades: _totalTrades,
            winningTrades: _winningTrades,
            executionLogHash: _executionLogHash,
            timestamp: block.timestamp,
            roundId: currentRound
        });
        
        roundParticipants[currentRound].push(_strategyId);
        totalPnL[_strategyId] += _pnl;
        
        emit ResultSubmitted(currentRound, _strategyId, _pnl);
    }
    
    // ç»“æŸå½“å‰è½®æ¬¡
    function finalizeRound() external {
        require(rounds[currentRound].startTime > 0, "No active round");
        require(!rounds[currentRound].finalized, "Already finalized");
        
        rounds[currentRound].endTime = block.timestamp;
        rounds[currentRound].finalized = true;
        
        emit RoundFinalized(currentRound);
    }
    
    // è·å–æ’è¡Œæ¦œ
    function getLeaderboard(uint256 limit) external view returns (
        uint256[] memory strategyIds,
        int256[] memory pnls
    ) {
        uint256 total = strategyNFT.totalStrategies();
        uint256 count = total < limit ? total : limit;
        
        strategyIds = new uint256[](count);
        pnls = new int256[](count);
        
        // ç®€åŒ–ç‰ˆï¼šç›´æ¥è¿”å›å‰Nä¸ªç­–ç•¥çš„PnL
        // å®Œæ•´ç‰ˆåº”è¯¥å®ç°æ’åº
        for (uint256 i = 1; i <= count; i++) {
            strategyIds[i-1] = i;
            pnls[i-1] = totalPnL[i];
        }
        
        return (strategyIds, pnls);
    }
    
    // è·å–æŸç­–ç•¥åœ¨ç‰¹å®šè½®æ¬¡çš„ç»“æœ
    function getResult(uint256 _roundId, uint256 _strategyId) 
        external view returns (TradingResult memory) 
    {
        return results[_roundId][_strategyId];
    }
    
    // éªŒè¯ç»“æœçš„å¯å¤ç°æ€§
    function verifyResult(
        uint256 _roundId,
        uint256 _strategyId,
        bytes32 _expectedLogHash
    ) external view returns (bool) {
        return results[_roundId][_strategyId].executionLogHash == _expectedLogHash;
    }
}
```

### Phase 3: éƒ¨ç½²è„šæœ¬ (30åˆ†é’Ÿ)

**scripts/deploy.ts:**
```typescript
import { ethers } from "hardhat";

async function main() {
  console.log("Deploying to 0G Galileo Testnet...");
  
  const [deployer] = await ethers.getSigners();
  console.log("Deploying with account:", deployer.address);
  
  // éƒ¨ç½² StrategyNFT
  const StrategyNFT = await ethers.getContractFactory("StrategyNFT");
  const strategyNFT = await StrategyNFT.deploy();
  await strategyNFT.waitForDeployment();
  console.log("StrategyNFT deployed to:", await strategyNFT.getAddress());
  
  // éƒ¨ç½² TradingArena
  const TradingArena = await ethers.getContractFactory("TradingArena");
  const tradingArena = await TradingArena.deploy(await strategyNFT.getAddress());
  await tradingArena.waitForDeployment();
  console.log("TradingArena deployed to:", await tradingArena.getAddress());
  
  // ä¿å­˜åˆçº¦åœ°å€
  console.log("\n--- Deployment Summary ---");
  console.log(`STRATEGY_NFT_ADDRESS=${await strategyNFT.getAddress()}`);
  console.log(`TRADING_ARENA_ADDRESS=${await tradingArena.getAddress()}`);
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
```

**éƒ¨ç½²å‘½ä»¤:**
```bash
npx hardhat run scripts/deploy.ts --network 0g-testnet
```

### Phase 4: å‰ç«¯å¼€å‘ (2å°æ—¶)

**å‰ç«¯æŠ€æœ¯æ ˆ:**
- Next.js 14 / React
- ethers.js v6
- @0glabs/0g-ts-sdk
- TailwindCSS
- wagmi + viem (é’±åŒ…è¿æ¥)

**å…³é”®ç»„ä»¶å®ç°:**

```typescript
// hooks/useContract.ts
import { ethers } from 'ethers';
import { useCallback } from 'react';
import StrategyNFTABI from '../abi/StrategyNFT.json';
import TradingArenaABI from '../abi/TradingArena.json';

const STRATEGY_NFT_ADDRESS = process.env.NEXT_PUBLIC_STRATEGY_NFT_ADDRESS!;
const TRADING_ARENA_ADDRESS = process.env.NEXT_PUBLIC_TRADING_ARENA_ADDRESS!;

export function useContracts() {
  const getProvider = useCallback(() => {
    if (typeof window !== 'undefined' && window.ethereum) {
      return new ethers.BrowserProvider(window.ethereum);
    }
    return new ethers.JsonRpcProvider('https://evmrpc-testnet.0g.ai');
  }, []);

  const getStrategyNFT = useCallback(async (withSigner = false) => {
    const provider = getProvider();
    const signerOrProvider = withSigner 
      ? await provider.getSigner() 
      : provider;
    return new ethers.Contract(STRATEGY_NFT_ADDRESS, StrategyNFTABI, signerOrProvider);
  }, [getProvider]);

  const getTradingArena = useCallback(async (withSigner = false) => {
    const provider = getProvider();
    const signerOrProvider = withSigner 
      ? await provider.getSigner() 
      : provider;
    return new ethers.Contract(TRADING_ARENA_ADDRESS, TradingArenaABI, signerOrProvider);
  }, [getProvider]);

  return { getStrategyNFT, getTradingArena, getProvider };
}
```

```typescript
// utils/0g-storage.ts
import { Indexer, ZgFile } from '@0glabs/0g-ts-sdk';
import { ethers } from 'ethers';

const INDEXER_RPC = 'https://indexer-storage-testnet-turbo.0g.ai';
const EVM_RPC = 'https://evmrpc-testnet.0g.ai';

export async function uploadStrategyToStorage(
  strategyCode: string,
  privateKey: string
): Promise<{ rootHash: string; txHash: string }> {
  const provider = new ethers.JsonRpcProvider(EVM_RPC);
  const signer = new ethers.Wallet(privateKey, provider);
  const indexer = new Indexer(INDEXER_RPC);
  
  // åˆ›å»ºä¸´æ—¶æ–‡ä»¶
  const blob = new Blob([strategyCode], { type: 'application/json' });
  const file = await ZgFile.fromBlob(blob);
  
  // è·å–merkle tree
  const [tree, err] = await file.merkleTree();
  if (err) throw new Error('Failed to create merkle tree');
  
  // ä¸Šä¼ åˆ°0G Storage
  const [tx, uploadErr] = await indexer.upload(file, EVM_RPC, signer);
  if (uploadErr) throw new Error(`Upload failed: ${uploadErr}`);
  
  await file.close();
  
  return {
    rootHash: tree!.rootHash(),
    txHash: tx!
  };
}

export async function downloadFromStorage(rootHash: string): Promise<string> {
  const indexer = new Indexer(INDEXER_RPC);
  
  // ä¸‹è½½æ–‡ä»¶å†…å®¹
  const content = await indexer.download(rootHash);
  return content;
}
```

```tsx
// components/StrategySubmit.tsx
'use client';
import { useState } from 'react';
import { ethers } from 'ethers';
import { useContracts } from '../hooks/useContract';
import { uploadStrategyToStorage } from '../utils/0g-storage';

export function StrategySubmit() {
  const [strategyCode, setStrategyCode] = useState('');
  const [strategyName, setStrategyName] = useState('');
  const [loading, setLoading] = useState(false);
  const [result, setResult] = useState<{ tokenId: string; storageRoot: string } | null>(null);
  const { getStrategyNFT } = useContracts();

  const handleSubmit = async () => {
    if (!strategyCode || !strategyName) return;
    
    setLoading(true);
    try {
      // 1. è®¡ç®—ç­–ç•¥ä»£ç hash
      const codeHash = ethers.keccak256(ethers.toUtf8Bytes(strategyCode));
      const paramsHash = ethers.keccak256(ethers.toUtf8Bytes(strategyCode));
      const datasetVersion = 'v1';
      const evalWindow = '2025-01-01~2025-02-01';
      
      // 2. ä¸Šä¼ åˆ°0G Storage (ç®€åŒ–ç‰ˆï¼šç›´æ¥ä½¿ç”¨hash)
      // const { rootHash } = await uploadStrategyToStorage(strategyCode, privateKey);
      const storageRoot = codeHash; // MVPç®€åŒ–
      
      // 3. åˆ›å»ºNFTå…ƒæ•°æ®
      const metadata = {
        name: strategyName,
        description: 'AI Trading Strategy',
        attributes: [
          { trait_type: 'Code Hash', value: codeHash },
          { trait_type: 'Params Hash', value: paramsHash },
          { trait_type: 'Dataset Version', value: datasetVersion },
          { trait_type: 'Eval Window', value: evalWindow },
          { trait_type: 'Created At', value: new Date().toISOString() }
        ]
      };
      const tokenURI = `data:application/json;base64,${btoa(JSON.stringify(metadata))}`;
      
      // 4. è°ƒç”¨åˆçº¦æ³¨å†Œç­–ç•¥
      const contract = await getStrategyNFT(true);
      const tx = await contract.registerStrategy(
        codeHash,
        paramsHash,
        datasetVersion,
        evalWindow,
        storageRoot,
        tokenURI
      );
      const receipt = await tx.wait();
      
      // 5. è·å–tokenId
      const event = receipt.logs.find((log: any) => 
        log.fragment?.name === 'StrategyRegistered'
      );
      const tokenId = event?.args?.[0]?.toString() || 'Unknown';
      
      setResult({ tokenId, storageRoot });
    } catch (error) {
      console.error('Submit failed:', error);
      alert('æäº¤å¤±è´¥ï¼Œè¯·æ£€æŸ¥é’±åŒ…è¿æ¥');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="bg-gray-800 rounded-lg p-6">
      <h2 className="text-2xl font-bold mb-4">ğŸ“ æ³¨å†Œäº¤æ˜“ç­–ç•¥</h2>
      
      <div className="space-y-4">
        <div>
          <label className="block text-sm mb-2">ç­–ç•¥åç§°</label>
          <input
            type="text"
            value={strategyName}
            onChange={(e) => setStrategyName(e.target.value)}
            className="w-full bg-gray-700 rounded px-4 py-2"
            placeholder="My Awesome Strategy"
          />
        </div>
        
        <div>
          <label className="block text-sm mb-2">ç­–ç•¥ä»£ç  (JSONæ ¼å¼)</label>
          <textarea
            value={strategyCode}
            onChange={(e) => setStrategyCode(e.target.value)}
            className="w-full bg-gray-700 rounded px-4 py-2 h-40 font-mono text-sm"
            placeholder={`{
  "type": "momentum",
  "params": {
    "lookback": 20,
    "threshold": 0.02
  }
}`}
          />
        </div>
        
        <button
          onClick={handleSubmit}
          disabled={loading}
          className="w-full bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 
                     rounded py-3 font-bold transition-colors"
        >
          {loading ? 'æäº¤ä¸­...' : 'ğŸš€ æ³¨å†Œç­–ç•¥ (é“¸é€ NFT)'}
        </button>
        
        {result && (
          <div className="mt-4 p-4 bg-green-900/50 rounded">
            <p>âœ… ç­–ç•¥æ³¨å†ŒæˆåŠŸ!</p>
            <p className="text-sm text-gray-400 mt-2">
              Token ID: {result.tokenId}
            </p>
            <p className="text-sm text-gray-400 truncate">
              Storage Root: {result.storageRoot}
            </p>
          </div>
        )}
      </div>
    </div>
  );
}
```

```tsx
// components/Leaderboard.tsx
'use client';
import { useEffect, useState } from 'react';
import { useContracts } from '../hooks/useContract';

interface LeaderboardEntry {
  rank: number;
  strategyId: string;
  pnl: number;
  creator: string;
}

export function Leaderboard() {
  const [entries, setEntries] = useState<LeaderboardEntry[]>([]);
  const [loading, setLoading] = useState(true);
  const { getStrategyNFT, getTradingArena } = useContracts();

  useEffect(() => {
    loadLeaderboard();
  }, []);

  const loadLeaderboard = async () => {
    try {
      const arena = await getTradingArena();
      const nft = await getStrategyNFT();
      
      const [strategyIds, pnls] = await arena.getLeaderboard(10);
      
      const entriesData = await Promise.all(
        strategyIds.map(async (id: bigint, index: number) => {
          const strategy = await nft.getStrategy(id);
          return {
            rank: index + 1,
            strategyId: id.toString(),
            pnl: Number(pnls[index]) / 100, // basis points to percentage
            creator: strategy.creator
          };
        })
      );
      
      // æŒ‰PnLæ’åº
      entriesData.sort((a, b) => b.pnl - a.pnl);
      entriesData.forEach((entry, i) => entry.rank = i + 1);
      
      setEntries(entriesData);
    } catch (error) {
      console.error('Failed to load leaderboard:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="bg-gray-800 rounded-lg p-6">
      <h2 className="text-2xl font-bold mb-4">ğŸ† ç­–ç•¥æ’è¡Œæ¦œ</h2>
      
      {loading ? (
        <p className="text-center py-8">åŠ è½½ä¸­...</p>
      ) : entries.length === 0 ? (
        <p className="text-center py-8 text-gray-400">æš‚æ— ç­–ç•¥å‚èµ›</p>
      ) : (
        <table className="w-full">
          <thead>
            <tr className="border-b border-gray-700">
              <th className="text-left py-2">æ’å</th>
              <th className="text-left py-2">ç­–ç•¥ID</th>
              <th className="text-right py-2">ç´¯è®¡æ”¶ç›Š</th>
              <th className="text-left py-2">åˆ›å»ºè€…</th>
            </tr>
          </thead>
          <tbody>
            {entries.map((entry) => (
              <tr key={entry.strategyId} className="border-b border-gray-700/50">
                <td className="py-3">
                  {entry.rank === 1 ? 'ğŸ¥‡' : entry.rank === 2 ? 'ğŸ¥ˆ' : entry.rank === 3 ? 'ğŸ¥‰' : `#${entry.rank}`}
                </td>
                <td className="py-3">
                  <span className="font-mono">#{entry.strategyId}</span>
                </td>
                <td className={`py-3 text-right font-bold ${entry.pnl >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                  {entry.pnl >= 0 ? '+' : ''}{entry.pnl.toFixed(2)}%
                </td>
                <td className="py-3 text-gray-400 truncate max-w-[150px]">
                  {entry.creator.slice(0, 6)}...{entry.creator.slice(-4)}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
      
      <button
        onClick={loadLeaderboard}
        className="mt-4 w-full bg-gray-700 hover:bg-gray-600 rounded py-2 transition-colors"
      >
        ğŸ”„ åˆ·æ–°æ’è¡Œæ¦œ
      </button>
    </div>
  );
}
```

### Phase 5: æµ‹è¯•ä¸éƒ¨ç½² (30åˆ†é’Ÿ)

```bash
# 1. ç¼–è¯‘åˆçº¦
npx hardhat compile

# 2. è·å–æµ‹è¯•ä»£å¸
# è®¿é—® https://faucet.0g.ai/ è·å–0.1 OG

# 3. éƒ¨ç½²åˆ°æµ‹è¯•ç½‘
npx hardhat run scripts/deploy.ts --network 0g-testnet

# 4. éªŒè¯åˆçº¦ (å¯é€‰)
npx hardhat verify --network 0g-testnet <CONTRACT_ADDRESS>

# 5. å‰ç«¯æ„å»º
cd frontend && npm run build

# 6. éƒ¨ç½²å‰ç«¯ (Vercel/Netlify)
vercel deploy
```

---

## âœ… MVP äº¤ä»˜æ¸…å•ï¼ˆæœ€å°åˆçº¦ + æœ€å°å‰ç«¯ï¼‰

### MVP éªŒæ”¶æ¸…å•ï¼ˆä¸æ¯”èµ›ç›®æ ‡å¯¹é½ï¼‰
- éƒ¨ç½²åˆ° 0G Galileo æµ‹è¯•ç½‘ï¼ˆchainId=16602ï¼‰
- ç­–ç•¥æ³¨å†Œé“¾ä¸Šç•™ç—•ï¼ˆcodeHash/paramsHash/datasetVersion/evalWindowï¼‰
- å›æµ‹/æ¨¡æ‹Ÿç»“æœå¯å¤ç®—ï¼Œ`backtestLogHash` å¯å¯¹æ¯”ä¸€è‡´
- å­˜è¯ææ–™å¯å¤æ ¸ï¼ˆç­–ç•¥æ–‡ä»¶ã€å‚æ•° JSONã€å›æµ‹æ—¥å¿—åŸæ–‡ï¼‰
- æ’è¡Œæ¦œ/ç»“æœå±•ç¤ºå¯ç”¨ï¼ˆå•ä¸€æŒ‡æ ‡å¦‚æ”¶ç›Šç‡ï¼‰

### é“¾ä¸Šæœ€å°å¯éªŒè¯å­—æ®µ
- `codeHash`ã€`paramsHash`
- `datasetVersion`ã€`evalWindow`
- `backtestLogHash`
- `strategyId`ã€`creator`ã€`createdAt`

### éƒ¨ç½²é…ç½®ï¼ˆæœ€å°å¿…è¦ï¼‰
- RPC: `https://evmrpc-testnet.0g.ai`
- Chain ID: `16602`
- Storage Indexer: `https://indexer-storage-testnet-turbo.0g.ai`
- EVM Version: `cancun`ï¼ˆHardhat/Foundry å¿…è®¾ï¼‰

### éªŒè¯æ­¥éª¤ï¼ˆå¯å¤ç°æ€§ï¼‰
1. è¯»å–é“¾ä¸Šå­—æ®µä¸ `backtestLogHash`
2. ä» 0G Storage ä¸‹è½½ç­–ç•¥/å‚æ•°/æ—¥å¿—
3. æœ¬åœ°å¤ç®—æ—¥å¿—å¹¶é‡ç®—å“ˆå¸Œ
4. å¯¹æ¯”é“¾ä¸Šå“ˆå¸Œä¸€è‡´å³é€šè¿‡

### æ‰©å±•è·¯å¾„ï¼ˆå¯é€‰ï¼‰
- Computeï¼šæ¥å…¥ `@0glabs/0g-serving-broker` å®Œæˆæ¨ç†ä¸å“åº”éªŒè¯
- DAï¼šä»…åœ¨éœ€è¦å¯ç”¨æ€§è¯æ˜/rollup æ—¶å¼•å…¥

---

## ğŸ”‘ å…³é”®é…ç½®ä¿¡æ¯

### 0G Galileo Testnet é…ç½®

| é…ç½®é¡¹ | å€¼ |
|--------|-----|
| Network Name | 0G Galileo Testnet |
| Chain ID | 16602 |
| RPC URL | https://evmrpc-testnet.0g.ai |
| Currency Symbol | OG |
| Block Explorer | https://chainscan-galileo.0g.ai |
| Faucet | https://faucet.0g.ai |

### 0G Storage é…ç½®

| æœåŠ¡ | URL |
|------|-----|
| Indexer RPC | https://indexer-storage-testnet-turbo.0g.ai |
| Flow Contract | 0x22E03a6A89B950F1c82ec5e74F8eCa321a105296 |

### 0G DA é…ç½®

| æœåŠ¡ | åœ°å€ |
|------|------|
| DAEntrance | 0xE75A073dA5bb7b0eC622170Fd268f35E675a957B |

---

## ğŸª Demo æ¼”ç¤ºæµç¨‹

1. **è¿æ¥é’±åŒ…** â†’ MetaMask è¿æ¥åˆ° 0G æµ‹è¯•ç½‘
2. **æ³¨å†Œç­–ç•¥** â†’ æäº¤ç­–ç•¥ä»£ç ï¼Œé“¸é€  NFT
3. **å¼€å§‹ç«èµ›** â†’ ç®¡ç†å‘˜å¯åŠ¨æ–°ä¸€è½®ç«èµ›
4. **æäº¤ç»“æœ** â†’ æ¨¡æ‹Ÿæ‰§è¡Œåæäº¤ç»“æœ
5. **æŸ¥çœ‹æ’å** â†’ æ’è¡Œæ¦œå®æ—¶æ›´æ–°
6. **éªŒè¯ç»“æœ** â†’ å±•ç¤ºç»“æœå¯éªŒè¯æ€§

---

## ğŸ”® åç»­æ‰©å±•æ–¹å‘

### çŸ­æœŸ (æ¯”èµ›å1å‘¨)
- [ ] é›†æˆçœŸå® 0G Storage ä¸Šä¼ 
- [ ] å®ç° 0G Compute å¯ä¿¡æ‰§è¡Œ
- [ ] æ·»åŠ æ›´å¤šäº¤æ˜“ç­–ç•¥æ¨¡æ¿

### ä¸­æœŸ (1ä¸ªæœˆ)
- [ ] å®Œæ•´ ERC-7857 INFT å®ç°
- [ ] çœŸå®å¸‚åœºæ•°æ®æ¥å…¥
- [ ] ç­–ç•¥å›æµ‹å¼•æ“

### é•¿æœŸ
- [ ] å»ä¸­å¿ƒåŒ–ç­–ç•¥æ‰§è¡Œç½‘ç»œ
- [ ] è´¨æŠ¼ä¸å¥–åŠ±æœºåˆ¶
- [ ] è·¨é“¾ç­–ç•¥æ”¯æŒ

---

## ğŸ“š å‚è€ƒèµ„æ–™

- [0G Documentation](https://docs.0g.ai/)
- [0G Builder Hub](https://build.0g.ai/)
- [0G TypeScript SDK](https://github.com/0gfoundation/0g-ts-sdk)
- [ERC-7857 Standard](https://docs.0g.ai/developer-hub/building-on-0g/inft/erc7857)
- [Hardhat Documentation](https://hardhat.org/docs)

---

**ç¥æ¯”èµ›é¡ºåˆ©ï¼ğŸš€**
